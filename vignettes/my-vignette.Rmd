---
title: "Example of the Vignette"
author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{IVMTE}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
require(pander)
require(ivmte)
```

```{r, startTime, echo = FALSE, result='hide'}
startTime <- proc.time()
```

# Package description

The marginal treatment effect was introduced by Heckman and
Vytlacil (2005) to provide a
choice-theoretic interpretation to instrumental variables models that
maintain the monotonicity condition of Imbens and Angrist (1994). 
This interpretation can be used to extrapolate from
the compliers to estimate treatment effects for other subpopulations. This
package provides a flexible set of methods for conducting this
extrapolation. It allows for parametric or nonparametric sieve estimation,
and allows the user to maintain shape restrictions such as monotonicity. The
package operates in the general framework developed by Mogstad, Santos and
Torgovitsky (2018), and accommodates either point
identification or partial identification (bounds). In the partially
identified case, bounds are computed using linear programming. 

Support for three linear programming solvers is provided:

1. Gurobi and the Gurobi R API
can be obtained from <http://www.gurobi.com/index>. 
1. CPLEX can be obtained
from <https://www.ibm.com/analytics/cplex-optimizer>. CPLEX R APIs 'Rcplex'
and 'cplexAPI' are available from CRAN. 
1. The lp_solve library is freely
available from <http://lpsolve.sourceforge.net/5.5/>, and is included when
installing either of its R APIs, 'lpSolve' or 'lpSolveAPI', which are
available from CRAN.

# Data

The package comes with various simulated data sets. Below are five random
entries from the data set `dtm`, which is included in the `ivmte` package.

```{r, constructDtmTable, echo=FALSE}
exampleTable <- dtm[sample(seq(1, nrow(dtm)), 5), ]
rownames(exampleTable) <- NULL
knitr::kable(exampleTable)
```

The table was generated by the following lines of code.
```{r, displayDtm, eval=FALSE}
exampleTable <- dtm[sample(seq(1, nrow(dtm)), 5), ]
rownames(exampleTable) <- NULL
knitr::kable(exampleTable)
```

# Examples

And now some examples.

## Example 1: Partially Identified Case

Below is an example of how to estimate the bounds on the average treatment
effect usingi the `dtm` data set.

```{r, partialCode, eval=FALSE}
ivlike <- c(ey ~ 1 + d,
            ey ~ 1 + d | factor(z))

result <- ivmte(ivlike = ivlike,
                data = dtm,
                components = l(),
                propensity = d ~ z ,
                link = "logit",
                m0 = ~ u + I(u^2),
                m1 = ~ u + I(u^2),
                uname = u,
                target = "ate",
                lpsolver = "gurobi")
```

The code shown above is not actually run when knitting the Vignette. This can be
achieved by declaring the option `eval=FALSE` for the 'code chunk'. The output
from the above command code is displayed below.

```{r, partialRun1, echo=FALSE, results='markdown'}
ivlike <- c(ey ~ 1 + d,
            ey ~ 1 + d | factor(z))

result <- ivmte(ivlike = ivlike,
                data = dtm,
                components = l(),
                propensity = d ~ z ,
                link = "logit",
                m0 = ~ u + I(u^2),
                m1 = ~ u + I(u^2),
                uname = u,
                target = "ate",
                lpsolver = "gurobi")
```

To generate the above output, I had to include the same code chunk as before,
but allowing `knitr` to evaluate the code. This can be done by declaring the
option `eval=TRUE`, which is the default option. To omit the code, the option
`echo=FALSE` is also declared. Finally, the results are displayed in the
`markdown` style. Output can alternatively be presented 'as is' by declaring
the option `results='asis'`. 

Below is the output when the option `results='asis'` is declared. Note that the
estimation procedure had to be run again.

```{r, partialRun2, echo=FALSE, results='markdown'}
result <- ivmte(ivlike = ivlike,
                data = dtm,
                components = l(),
                propensity = d ~ z ,
                link = "logit",
                m0 = ~ u + I(u^2),
                m1 = ~ u + I(u^2),
                uname = u,
                target = "ate",
                lpsolver = "gurobi")
```

Below are some examples of what is returned by the function `ivmte` under
partial identification.

```{r, partialResults}
result$bound
## Display the IV coefficient and gamma moments corresponding to the 
## `d' component in the second IV specification.
result$sset$s4
## Display the propensity score model.
result$propensity$model
```


## Example 2: Point Identified Case

In this second example, I generate a data set using one of the build-in commands
of the `ivmte` package.

```{r, constructSmallData}
set.seed(10L)
smallData <- ivmte:::gendist1e(N = 1000)
```

The data takes the following form.

```{r, displaySmallData, echo=FALSE}
knitr::kable(head(smallData))
```

On this data, I estimate the ATE under point identification. I also request that
inference be conducted via 100 bootstraps.

```{r, bootstrapCode, eval=FALSE}
ivlike <- c(y ~ 1 + d,
            y ~ 1 + d | 1 + z)

vignetteResult <- ivmte(ivlike = ivlike,
                        data = smallData,
                        components = l(c(d), ),
                        propensity = d ~ z ,
                        link = "logit",
                        m0 = ~ 0 + u,
                        m1 = ~ u,
                        uname = u,
                        target = "ate",
                        lpsolver = "gurobi",
                        point = TRUE,
                        bootstraps = 100)
```

This could take _some time_ to run...

```{r, bootstrapRun, eval=TRUE, echo=FALSE}
ivlike <- c(y ~ 1 + d,
            y ~ 1 + d | 1 + z)

vignetteResult <- ivmte(ivlike = ivlike,
                        data = smallData,
                        components = l(c(d), ),
                        propensity = d ~ z ,
                        link = "logit",
                        m0 = ~ 0 + u,
                        m1 = ~ u,
                        uname = u,
                        target = "ate",
                        lpsolver = "gurobi",
                        point = TRUE,
                        bootstraps = 3)
```

So I performed the full estimation separately from this vignette
script, and saved the results so that they are exported with the package.
Now the vignette can call on this saved result. The reason I did this was 
because we discussed how recompiling the vignette could be annoyingly slow if 
it involved some long R procedure. So this is one way to address that issue. 
Also, the R code in vignettes are required to be able to run.^[Error handling 
can be demonstrated by declaring the option `error=TRUE` for the code chunk.] 
So if I want to then interact with the results of the example code, I would need
to somehow make the output available. Exporting the saved results with the 
package sems to also address this requirement.

Below are some examples of what is returned by the function `ivmte` under
point identification and conducting inference via bootstrap.
```{r, bootstrapResults}
vignetteResult$pointestimate
vignetteResult$pointestimate.se
## The confidence interval is calculated using the quantile method
vignetteResult$pointestimate.ci1.90
vignetteResult$mtr.ci1.90
```

# Total Compilation Time

Thought I'd throw this in. Obviously, this will depend
on the examples included.


```{r, endTime, echo = FALSE, result='hide'}
totalTime <- proc.time() - startTime
```

__Total time to compile:__ `r totalTime[1]` seconds.
